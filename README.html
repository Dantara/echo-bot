<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>README.html</title>
<meta http-equiv="Content-Type" content="application/xhtml+xml;charset=utf-8"/>
<link rel="stylesheet" type="text/css" media="all" href="https://cdn.jsdelivr.net/npm/github-markdown-css/github-markdown.min.css"  />
<link rel="stylesheet" type="text/css" media="all" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/styles/github.min.css"  /><meta name='viewport' content='width=device-width, initial-scale=1, shrink-to-fit=no'><style> body { box-sizing: border-box; max-width: 740px; width: 100%; margin: 40px auto; padding: 0 10px; } </style><script id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'></script><script src='https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/highlight.min.js'></script><script>document.addEventListener('DOMContentLoaded', () => { document.body.classList.add('markdown-body'); document.querySelectorAll('pre[lang] > code').forEach((code) => { code.classList.add(code.parentElement.lang); }); document.querySelectorAll('pre > code').forEach((code) => { hljs.highlightBlock(code); }); });</script>
</head>

<body>

<h1>Echo-bot</h1>

<p>This repository contains simple polymorphic echo bot for VK and Telegram.</p>

<p>This application build on top of <a href="https://hackage.haskell.org/package/req">req</a> to proceed request to messengers servers and uses <a href="http://okmij.org/ftp/tagless-final/index.html">Tagless Final</a> approach to abstract business logic over concrete implementation.</p>

<p><em>NOTE</em>: The application was created for education purpose.</p>

<h3>Prerequisites</h3>

<p>This project relies on the <a href="https://docs.haskellstack.org/en/stable/README/">Haskell Stack tool</a>.</p>

<h2>Config</h2>

<p>This applications uses external config file called <code>bot.config</code> to set up its behavour.</p>

<p>The sample config is placed into root directory of this repository.</p>

<p><em>NOTE</em>: The <code>log_level</code> can be either <code>debug</code>, <code>info</code>, <code>warning</code> or <code>error</code>.
Delays are specified in miliseconds.</p>

<h2>Build</h2>

<p>To build this project simply run</p>

<p><code>sh
stack build
</code></p>

<p>This will install all dependencies, including a proper version of GHC.</p>

<h2>Run</h2>

<p>This project has one executable that you can run with</p>

<p><code>sh
stack exec echo-bot-exe
</code></p>

<h2>Test</h2>

<p>Tests of this project relies on <a href="https://hackage.haskell.org/package/tasty">Tasty</a>
framework with <a href="https://hackage.haskell.org/package/HUnit">HUnit</a>
and <a href="https://hackage.haskell.org/package/hedgehog">Hedgehog</a> addons for unit tests
and property-based ones.</p>

<p>To run tests simply run</p>

<p><code>sh
stack test
</code></p>

<h2>Project structure overview</h2>

<p>The main logic of whole application is placed into <code>src</code> folder (default for stack).
Here you can examine file structure of this folder:</p>

<p><code>sh
.
├── Bot
│   ├── Shared
│   │   └── RepeatCommandHandler.hs
│   ├── Shared.hs
│   ├── Telegram
│   │   ├── Fetcher.hs
│   │   ├── Sender.hs
│   │   ├── Translator.hs
│   │   └── Types
│   │       ├── Config.hs
│   │       ├── Msg.hs
│   │       ├── Shared.hs
│   │       └── Updates.hs
│   ├── Telegram.hs
│   ├── VK
│   │   ├── Fetcher
│   │   │   └── LongPollServer.hs
│   │   ├── Fetcher.hs
│   │   ├── Sender
│   │   │   ├── Keyboard.hs
│   │   │   └── Keyboard.json
│   │   ├── Sender.hs
│   │   ├── Translator.hs
│   │   └── Types
│   │       ├── Config.hs
│   │       ├── Msg.hs
│   │       ├── Shared.hs
│   │       └── Updates.hs
│   └── VK.hs
├── Bot.hs
├── Config.hs
├── Helpers.hs
├── Logger.hs
└── Logic.hs
</code></p>

<h3>Business logic</h3>

<p>All business logic is placed into <code>Logic.hs</code> file. Business logic are expressed in
tagless final style. It separated into three parts:</p>

<ul>
<li><strong>Fetcher</strong> - fetches updates from messanger server and push them into queue.</li>
<li><strong>Translator</strong> - pulls updates from the queue, transform them into messages ready to send (it is also handles repetitions) and then push them to the second queue.</li>
<li><strong>Sender</strong> - simply pulls messages from queue and send them to messanger server.</li>
</ul>


<p>Here you can see diagram of business logic structure:</p>

<p><img src="./docs/logic.png" title="Logic structure" alt="" /></p>

<p>An advantages of this separted business logic into different small parts is ability
to run each of them in separate thread (their connection is provided via <code>STM Queue</code>).</p>

<p>This architecture provides an ability of not linear system scaling:</p>

<p><img src="./docs/logic-scaled.png" title="Logic scaled" alt="" /></p>

<h3>Type classes</h3>

<p>The main set of type classes and and their default implementation is placed into <code>Bot.hs</code> file.</p>

<h3>Config</h3>

<p>The main logic for config reading is placed into <code>Config.hs</code> file.
Files called <code>Bot/Telegram/Types/Config.hs</code> and <code>Bot/VK/Types/Config.hs</code>
contains parsing functions for these concrete config parts.</p>

<h3>Logger</h3>

<p>The logger logic and data types are placed into <code>Logger.hs</code> file.
Logger also uses typeclass approach to provide its functionality.
There are to default loggers implementation STD logger
(which prints log messages into console) and Identity one
(which mocks all log messages).</p>

</body>
</html>
